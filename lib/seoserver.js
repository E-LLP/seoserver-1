// Generated by CoffeeScript 1.3.3
(function() {
  var $, SeoServer, args, express, logentries, memcached, seoserver, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  express = require('express');

  memcached = require('memcached');

  $ = require('jquery');

  _ = require('underscore');

  logentries = require('node-logentries');

  SeoServer = (function() {

    SeoServer.prototype.defaultConfig = {
      host: 'http://moviepilot.com',
      defaultPort: 10300,
      memcached: {
        enabled: true,
        defaultHost: 'localhost',
        defaultPort: 11211,
        maxValue: 2097152,
        connectRetries: 5,
        key: 'moviepilot.com'
      },
      logentries: {
        enabled: false,
        token: 'YOUR_LOGENTRIES_TOKEN_HERE'
      }
    };

    function SeoServer(config) {
      if (config == null) {
        config = {};
      }
      this.storeResponseInCache = __bind(this.storeResponseInCache, this);

      this.responseHandler = __bind(this.responseHandler, this);

      this.start = __bind(this.start, this);

      this.config = _.defaults(config, this.defaultConfig);
      console.log("Launching with config: ", this.config);
    }

    SeoServer.prototype.start = function() {
      var dfd,
        _this = this;
      dfd = $.Deferred();
      memcached = this.initMemcached();
      memcached.fail(function(error) {
        return console.log("Got memcached connection error: " + error);
      });
      memcached.done(function(connection) {
        return console.log("Connected to memcached.");
      });
      memcached.always(function() {
        console.log("Express server started at port " + _this.config.defaultPort);
        _this.app = express();
        _this.app.get(/(.*)/, _this.responseHandler);
        _this.app.listen(_this.config.defaultPort);
        return dfd.resolve();
      });
      return dfd.promise();
    };

    SeoServer.prototype.responseHandler = function(request, response) {
      var now,
        _this = this;
      this.timer = 0;
      now = +new Date();
      return this.fetchPage(request, response).done(function(url, headers, content) {
        _this.logResponseStats(request, headers, +(new Date) - now);
        response.status(headers.status || 500);
        if (headers.contentType) {
          response.header("Content-type", headers.contentType);
        }
        response.header("Access-Control-Allow-Origin", "*");
        response.header("Access-Control-Allow-Headers", "X-Requested-With");
        if (headers.location != null) {
          response.set('Location', headers.location);
          return response.send('');
        } else {
          return response.send(content);
        }
      });
    };

    SeoServer.prototype.fetchPage = function(request, response) {
      var dfd, fetchDfd, url,
        _this = this;
      dfd = $.Deferred();
      url = this.config.host + request.url;
      if (this.memcachedClient) {
        fetchDfd = this.fetchFromMemcached(request);
      } else {
        fetchDfd = this.fetchFromPhantom(url);
      }
      fetchDfd.fail(function() {
        return dfd.reject();
      });
      fetchDfd.done(function(url, headers, content) {
        _this.storeResponseInCache(request, headers, content);
        return dfd.resolve(url, headers, content);
      });
      return dfd.promise();
    };

    SeoServer.prototype.storeResponseInCache = function(request, headers, content) {
      var key, uri, _ref;
      if (!this.memcachedClient) {
        return;
      }
      if (headers.status === 301) {
        content = "301 " + headers.location;
      }
      uri = this.config.host + request.path;
      key = this.config.memcached.key + uri;
      if (headers.status >= 200 && (headers.status < 300 || ((_ref = headers.status) === 301 || _ref === 302))) {
        return this.memcachedClient.set(key, content, 0, function(err) {
          if (err) {
            return console.log(err);
          }
        });
      }
    };

    SeoServer.prototype.fetchFromMemcached = function(request) {
      var clearCache, dfd, key, uri, url,
        _this = this;
      dfd = $.Deferred();
      url = this.config.host + request.url;
      uri = this.config.host + request.path;
      key = this.config.memcached.key + uri;
      clearCache = request.query.plan === 'titanium';
      this.memcachedClient.get(key, function(error, cachedContent) {
        var headers, matches, phantomRequest;
        if (error) {
          return dfd.reject("memcached error: " + error);
        }
        if (cachedContent && !clearCache) {
          headers = {};
          if (/^301/.test(cachedContent)) {
            matches = cachedContent.match(/\s(.*)$/);
            headers.status = 301;
            headers.location = matches[1];
          }
          headers.memcached = true;
          return dfd.resolve(url, headers, cachedContent);
        } else {
          phantomRequest = _this.fetchFromPhantom(url);
          phantomRequest.done(dfd.resolve);
          return phantomRequest.fail(dfd.fail);
        }
      });
      return dfd.promise();
    };

    SeoServer.prototype.fetchFromPhantom = function(url) {
      var content, dfd, headers, phantom, timeout,
        _this = this;
      dfd = $.Deferred();
      timeout = null;
      headers = {};
      content = '';
      phantom = require('child_process').spawn('phantomjs', [__dirname + '/phantom-server.js', url]);
      timeout = setTimeout(function() {
        return phantom.kill();
      }, 30000);
      phantom.stdout.on('data', function(data) {
        var match, responseHeaders;
        data = data.toString();
        if (match = data.match(/({.*?})\n\n/)) {
          responseHeaders = JSON.parse(match[1]);
          if (responseHeaders.status) {
            headers.status = responseHeaders.status;
          }
          if (responseHeaders.status === 301) {
            headers.location = responseHeaders.redirectURL;
          }
          headers.contentType = responseHeaders["contentType"];
          data = data.replace(/(.*?)\n\n/, '');
        }
        if (data.match(/^\w*error/i)) {
          headers.status = 503;
          return console.log("Phantom js error: " + data.toString());
        } else {
          return content += data.toString();
        }
      });
      phantom.stderr.on('data', function(data) {
        return console.log('stderr: ' + data);
      });
      phantom.on('exit', function(code) {
        clearTimeout(timeout);
        if (code) {
          console.log('Error on Phantomjs process');
          return dfd.fail(code);
        } else {
          content = _this.removeScriptTags(content);
          return dfd.resolve(url, headers, content);
        }
      });
      return dfd.promise();
    };

    SeoServer.prototype.initMemcached = function() {
      var client, dfd, server,
        _this = this;
      console.log("Initializing memcached client");
      dfd = $.Deferred();
      if (!this.config.memcached.enabled) {
        return dfd.reject('memcached is disabled');
      }
      memcached.config.retries = this.config.memcached.connectRetries;
      memcached.config.maxValue = this.config.memcached.maxValue;
      server = "" + this.config.memcached.defaultHost + ":" + this.config.memcached.defaultPort;
      client = new memcached(server);
      client.on('failure', function(details) {
        var error;
        error = "Memcached connection failure on: " + details.server + "        due to: " + (details.messages.join(' '));
        return dfd.reject(error);
      });
      client.on('reconnecting', function(details) {
        return console.log("memcached: Total downtime caused by server        " + details.server + " : " + details.totalDownTime + " ms");
      });
      console.log("Trying to connect to memcached server " + server);
      client.connect(server, function(error, connection) {
        if (error) {
          return dfd.reject(error);
        } else {
          _this.memcachedClient = client;
          return dfd.resolve();
        }
      });
      return dfd.promise();
    };

    SeoServer.prototype.logResponseStats = function(request, headers, time) {
      var crawler, status, url;
      url = request.originalUrl;
      url = url.replace(/.*moviepilot\.com/, "");
      status = headers.memcached ? "MEMCACHED" : headers.status ? headers.status : "KILLED";
      crawler = /RedSnapper/.test(request.headers['user-agent']) ? 'Crawler' : 'GoogleBot';
      console.log(crawler, status, "Time:", time + "ms", "|", (time / 1000).toFixed(2) + "s", url);
      if (this.config.logentries.enabled) {
        if (status === 503 || status === "KILLED") {
          return log.err({
            status: status,
            url: url
          });
        }
      }
    };

    SeoServer.prototype.removeScriptTags = function(content) {
      return content.replace(/<script[\s\S]*?<\/script>/gi, '');
    };

    return SeoServer;

  })();

  module.exports = SeoServer;

  args = process.argv.splice(2);

  if ((args != null ? args[0] : void 0) === 'start') {
    seoserver = new SeoServer();
    seoserver.start();
  }

}).call(this);
